/*
 * VYPa 2018 - VYPcode compiler.
 * Roman Andriushchenko (xandri03)
 */

package main;

import parser.GrammarParser;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.stream.Collectors;

/**
 * The core of the syntax-directed parsing.
 */
public class Program {

	/** Parse program context and fill symbol tables. */	
    public Program(GrammarParser parser) {
        // Initiate AST construction
        GrammarParser.ProgramContext program = parser.program();

        // Allocate table of classes
        Class.table = new SymbolTable<>();

        // Register built-in Object class
        Class classObject = new Class();
        classObject.name = "Object";
        Class.table.register(classObject);
        
        // Collect definitions of classes
        program.classDefinition().forEach(
        	ctx -> Class.table.register(Class.recognize(ctx))
        );

        // Establish class hierarchy
        Class.table.values().forEach(c -> c.collectBase());
        Class.table.values().forEach(c -> c.checkBase());

        // Allocate table of global functions
        Function.table = new SymbolTable<>();

        // Register built-in functions
        Function function;

        function = new Function();
        function.type = Type.VOID;
        function.name = "print";
        function.parameters = new ArrayList<>();
        Function.table.register(function);

        function = new Function();
        function.type = Type.INT;
        function.name = "readInt";
        function.parameters = new ArrayList<>();
        Function.table.register(function);

        function = new Function();
        function.type = Type.STRING;
        function.name = "readString";
        function.parameters = new ArrayList<>();
        Function.table.register(function);

        function = new Function();
        function.type = Type.INT;
        function.name = "length";
        function.parameters = new ArrayList<>();
        function.parameters.add(new Variable(Type.STRING, "s"));
        Function.table.register(function);

        function = new Function();
        function.type = Type.STRING;
        function.name = "subStr";
        function.parameters = new ArrayList<>();
        function.parameters.add(new Variable(Type.STRING, "s"));
        function.parameters.add(new Variable(Type.INT, "i"));
        function.parameters.add(new Variable(Type.INT, "n"));
        Function.table.register(function);

        // Collect global function headers
        program.functionDefinition().forEach(ctx -> {
        	Function.table.register(Function.recognize(ctx));
		});

        // Process all global functions declarations
        Function.table.values().forEach(f -> f.initialize());

        // Look up "main" and check its signature
        function = Function.table.lookUp("main");
        if(
        	function.type != Type.VOID
        	|| !function.signatureMatchExact(new ArrayList<>())
        ) {
            Recover.type("bad signature of function main");
        }

        // Collect class members
        Class.table.values().forEach(c -> c.collectMembers());

        // Collect procedure bodies
        Function.table.values().forEach(f -> f.collectBody());
        Class.table.values().forEach(c -> c.collectBody());

        // Indexate functions
        int index = 0;
        for(Function f: Function.table.values()) {
            f.indexate(index++);
        }
        
        // Establish a topological order of class hirerarchy and indexate
        // each class
        List<Class> classList = new ArrayList<>();
        Class.table.values().forEach(c -> c.order(classList));
        index = 0;
        for(Class c: classList) {
            c.indexate(index++);
        }
    }

    /** Generate program code. **/
    public String code() {
        Code.reset();
        Code.comment("Generated by: xandri03");
        Code.newline();

        Code.comment("$0 - framepointer");
        Code.println("ALIAS FP $0");
        Code.comment("$1 - function return value");
        Code.println("ALIAS RET $1");
        Code.comment("$2 - general-purpose register");
        Code.println("ALIAS R $2");
        Code.comment("$7 - table of VMTs");
        Code.println("ALIAS VMT $7");
        Code.comment("$3-6 may be used arbitrarily");
        Code.newline();

        Code.comment("Initialize named registers");
        Code.println("SET $FP 0");
        Code.println("SET $RET 0");
        Code.println("SET $R 0");
        Code.println("SET $VMT 0");
        Code.newline();
        
        Code.comment("Allocate a table of VMTs");
        Code.println("CREATE $VMT " + Class.table.values().size());
        Code.newline();

        Code.comment("Construct individual VMTs");
        Class.table.values().forEach(c -> c.codeVMT());
        Code.newline();

        Code.comment("Call main, exit afterwards");
        Code.println("CALL [$SP] ::main");
        Code.println("JUMP @exit");
        Code.newline();

        Code.separator3();
        Code.comment("***** GLOBAL FUNCTIONS *****");
        Code.newline();
        Function.table.values().forEach(f -> f.code());
        Code.newline();

        Code.separator3();
        Code.comment("***** CLASSES *****");
        Code.newline();
        Class.table.values().forEach(c -> c.code());
        Code.newline();
        
        Code.separator3();
        Code.label("@exit");
        Code.comment("END OF FILE");

        return Code.code();
    }
}