package main;

import java.util.List;
import java.util.ArrayList;

public class Code {
    private static StringBuilder sb = new StringBuilder();

    private static void print(String str) {
        sb.append(str);
    }

    private static void println(String str) {
        sb.append(str + "\n");
    }

    private static void newline() {
        sb.append("\n");
    }

    private static void comment(String str) {
    	println("# " + str);
    }

    private static void separator() {
    	println("# ----------------------");
    }

    public static String code() {
    	// Header
        comment("Generated by: xandri03");
        newline();

        comment("$0 - framepointer");
        comment("$1 - function return value");
        println("ALIAS FP $0");
        
		comment("$7 - table of VMTs");
        println("CREATE $7 " + SymbolTable.classes().size());
        
        comment("fill it with individual VMTs");
        SymbolTable.classes().forEach(c -> {
        	List<Function> vmt = c.VMT();
        	println("CREATE $6 " + vmt.size());
        	println("SETWORD $7 " + c.classIndex + " $6");
        	vmt.forEach(m -> {
        		String label = c.name + "::" + m.name;
	        	println("SETWORD $6 " +  m.order + " \"" + label + "\"");
        	});
        });
        

        newline();

        comment("call main, exit afterwards");
        println("CALL [$SP] ::main");
        println("JUMP @exit");
        newline();

        comment("***** GLOBAL FUNCTIONS *****");
        newline();
        SymbolTable.functions().forEach(f -> code(f));
        newline();

        comment("***** CLASSES *****");
        newline();
        SymbolTable.classes().forEach(c -> code(c));
        newline();
        
        println("LABEL @exit");
        newline();

        // Success
        return sb.toString();
    }

    public static void code(Class c) {
    	// Constructor
    	code(c.constructor);

    	// Methods
    	c.methodList.forEach(m -> code(m));
    }


    private static String labelTemplate;
    private static int labelOrder;


    public static void code(Function f) {
    	// Reset static fields
    	labelTemplate = "";
    	if(f.context != null) {
    		labelTemplate = f.context.name;
    	}    
		labelTemplate += "::"+ f.name;
    	labelOrder = 0;

    	// Skip ::print, ::readInt, ::readString
    	if(f.body == null) {
    		if(
    			f.name.equals("print") ||
    			f.name.equals("readInt") ||
    			f.name.equals("readString")
    		) {
    			return;
    		}
    	}

        separator();
        print("LABEL " + labelTemplate);
        newline();

        // Store frame pointer
        println("SET $FP $SP");

        // Allocate local variables, they will be initialized at their declaration site
        println("ADDI $SP $SP " + f.order);
        newline();

        // Generate code for statements
        if(f.context != null && f.context.name.equals(f.name)) {
        	Class c = f.context;
        	if(c.base == null) {
        		// Object::Object
        	} else {
	        	// Call base constructor
        		push("$FP");
				push("[$FP-1]");
				println("ADDI $SP $SP 1");
				println("CALL [$SP] " + c.base.name + "::" + c.base.name);
				println("SUBI $SP $SP 2");
				pop("$FP");
        	}

        	// Initialize fields
    		println("SET $1 [$FP-1]");
    		println("GETWORD $2 $7 " + c.classIndex);
    		println("SETWORD $1 0 $2");
        	c.attributeList.forEach(a -> {
        		String value = a.type == Type.STRING ? "\"\"" : "0";
        		println("SETWORD $1 " + (a.order+1) + " " + value);
        	});

        	// Do body
        	if(f.body != null) {
	        	f.body.forEach(s -> code(s));
        	}
        }
        else if(f.body == null) {
        	// Built-in ::length or ::subStr
        	if(f.context == null) {
	        	if(f.name.equals("length")) {
	        		// ::length
	        		println("GETSIZE $1 [$FP-1]");
	        		returnVoid();
	        	} else {
	        		// ::subStr

	        		// $1 = length(s);
	        		println("GETSIZE $1 [$FP-1]");
	        		
	        		// if(i < 0 || i == $1 || i > $1 || n < 0) {return "";}
	        		println("LTI $2 [$FP-2] 0");
	        		println("EQI $3 [$FP-2] $1");
	        		println("GTI $4 [$FP-2] $1");
	        		println("LTI $5 [$FP-3] 0");
	        		println("OR $2 $2 $3");
	        		println("OR $2 $2 $4");
	        		println("OR $2 $2 $5");
	        		println("JUMPNZ " + localLabelStr() + "return $2");
	        		
	        		// $2 = i + n - $1
	        		println("ADDI $2 [$FP-2] [$FP-3]");
	        		println("SUBI $2 $2 $1");
	        		
	        		// if($2 > 0) {n = n - $2}
	        		println("GTI $3 $2 0");
	        		println("JUMPZ " + localLabelStr() + "end_if $3");
	        		println("SUBI $2 [$FP-3] $2");
	        		println("SET [$FP-3] $2");
	        		localLabel("end_if");

	        		// $1 = alloc(n);
	        		// $2 = s;
	        		// $3 = 0;
	        		// while($3 < n) { $1[$3] = $2[i+$3]; $3 = $3 + 1;}
	        		println("CREATE $1 [$FP-3]");
	        		println("SET $2 [$FP-1]");
	        		println("SET $3 0");

	        		localLabel("while");
	    			println("LTI $4 $3 [$FP-3]");
	    			println("JUMPZ " + localLabelStr() + "end_while" + " $4");
	    			println("SET $4 [$FP-2]");
	    			println("ADDI $4 $4 $3");
	    			println("GETWORD $4 $2 $4");
	    			println("SETWORD $1 $3 $4");
	    			println("ADDI $3 $3 1");
	    			println("JUMP " + localLabelStr() + "while");
	    			localLabel("end_while");

	    			// return $1;
	    			returnVoid();

	        		localLabel("return");
	        		// return empty string on error
	        		println("SET $1 \"\"");
	        		returnVoid();

	        		labelOrder++;
	        	}
        	} else {
        		// Object methods
        		if(f.name.equals("toString")) {
					// Object::toString
					println("SET $1 \"\"");
                    returnVoid();
                } else if(f.name.equals("getClass")) {
                    // Object::getClass
                    println("SET $1 [$FP-1]");
                    println("GETWORD $1 $1 0");
					println("GETWORD $1 $1 1");
					returnVoid();
				}
        	}
        } else {
        	f.body.forEach(s -> code(s));
        }
        newline();

        comment("Hard return");
        if(f.type == Type.VOID) {
        } else if(f.type == Type.INT) {
            println("SET $1 0");
        } else if(f.type == Type.STRING) {
            println("SET $1 \"\"");
        } else {
            println("SET $1 0");
        }
        returnVoid();
        newline();
    }

    public static void code(Statement s) {
    	newline();

    	Variable v;
    	switch(s.option) {
    		case DECLARATION:
    			// Set default value
    			v = s.declaration;
    			if(v.type == Type.STRING) {
    				println(String.format("SET [$FP%+d] \"\"", v.order));
    			} else {
    				println(String.format("SET [$FP%+d] 0", v.order));
    			}
    			break;
    		case ASSIGNMENT:
    			code(s.ex);
    			if(s.path.path == null) {
    				pop(s.path.handle);
    			} else {
    				List<Variable> path = s.path.path;
    				println(String.format("SET $1 [$FP%+d]", s.path.handle.order));
    				for(int index = 0; index < path.size()-1; index++) {
	    				println("GETWORD $1 $1 " + (path.get(index).order+1));
    				}
    				println("SETWORD $1 " + (path.get(path.size()-1).order+1) + " [$SP]");
    				println("SUBI $SP $SP 1");
    			}
    			break;
    		case CONDITIONAL:
    			code(s.ex);
    			pop("$1");
    			println("JUMPZ " + localLabelStr() + "else" + " $1");
    			code(s.blockTrue);
    			println("JUMP " + localLabelStr() + "end_if");
    			localLabel("else");
    			code(s.blockFalse);
    			localLabel("end_if");
    			labelOrder++;
    			break;
    		case ITERATION:
    			localLabel("while");
    			code(s.ex);
    			pop("$1");
    			println("JUMPZ " + localLabelStr() + "end_while" + " $1");
    			code(s.blockTrue);
    			println("JUMP " + localLabelStr() + "while");
    			localLabel("end_while");
    			labelOrder++;
    			break;
    		case CALL:
    			code(s.call);
    			break;
    		case RETURN:
    			if(s.ex != null) {
    				code(s.ex);
    				pop("$1");
    			}
    			returnVoid();
    			break;
    	}
    }

    public static void code(Expression ex) {
    	if(ex.option == Expression.Option.LITERAL) {
    		push(ex.literal.text);
    		return;
    	}

    	if(ex.option == Expression.Option.PATH) {
            Path path = ex.path;
            Variable handle = path.handle;
    		if(path.path == null) {
                // atomic path
				if(ex.path.type == Type.STRING) {
                    println(String.format("COPY $1 [$FP%+d]", handle.order));
                    push("$1");
                } else {
                    push(handle);
                }
			} else {
                // composite path
				List<Variable> list = path.path;
				println(String.format("SET $1 [$FP%+d]", handle.order));
				for(int index = 0; index < list.size(); index++) {
    				println("GETWORD $1 $1 " + (list.get(index).order+1));
				}
				Variable last = list.get(list.size()-1);
				if(last.type == Type.STRING) {
					println("COPY $1 $1");
				}
				push("$1");	
			}
			return;
    	}

    	if(ex.option == Expression.Option.NEW) {
    		Class c = ex.classNew;
			push("$FP");
			println("CREATE $1 " + (c.attributeIndex+1));
			push("$1");
			println("ADDI $SP $SP 1");
			println("CALL [$SP] " + c.name + "::" + c.name);
			println("SUBI $SP $SP 1");
			pop("$1");
			pop("$FP");
			push("$1");
			return;
    	}

    	if(ex.option == Expression.Option.CALL) {
    		code(ex.call);
			push("$1");
			return;
    	}
    	
    	// Unary or binary operations
		code(ex.op1);

    	if(ex.option == Expression.Option.INT2STRING) {
			println("INT2STRING $1 [$SP]");
			println("SET [$SP] $1");
			return;
    	}

    	if(ex.option == Expression.Option.CAST) {
			Recover.notImplemented();
			return;
    	}

    	if(ex.option == Expression.Option.NEG) {
    		println("NOT $1 [$SP]");
			println("SET [$SP] $1");
    	}
    	
    	// Binary operations

		code(ex.op2);
		String opcode = null;
		boolean destroy = false;
		switch(ex.option) {
    		case MULI: opcode = "MULI"; break;
    		case DIVI: opcode = "DIVI"; break;
    		case ADDI: opcode = "ADDI"; break;
			case ADDS:
				// $1 = s1.length();
				// $2 = s1.length();
				// $4 = $1 + $2;
    			println("GETSIZE $1 [$SP-1]");
    			println("GETSIZE $2 [$SP]");
    			println("ADDI $4 $1 $2");

    			// $3 = copy($1);
    			// $3 = realloc($4);
				println("COPY $3 [$SP-1]");
				println("RESIZE $3 $4");

				// $4 = 0;
				// while($4 < $1) {
				//   $5 = [[$SP-1]+$4]
				//   [$3+$4] = ;
				//   $4 = $4 + 1;
				// }

				println("SET $4 0");
				localLabel("while");
    			println("SUBI $5 $1 $4");
    			println("JUMPZ " + localLabelStr() + "end_while" + " $5");
    			println("GETWORD $5 [$SP-1] $4");
    			println("SETWORD $3 $4 $5");
    			println("ADDI $4 $4 1");
    			println("JUMP " + localLabelStr() + "while");
    			localLabel("end_while");
    			labelOrder++;

    			// $4 = 0;
				// while($4 < $2) {
    			//   $5 = $1 + $4
				//   $5 = [[$SP-1]+$5]
				//   [$3+$4] = ;
				//   $4 = $4 + 1;
				// }

				println("SET $4 0");
				localLabel("while");
    			println("SUBI $5 $2 $4");
    			println("JUMPZ " + localLabelStr() + "end_while" + " $5");
    			println("ADDI $5 $1 $4");
    			println("GETWORD $6 [$SP] $4");
    			println("SETWORD $3 $5 $6");
    			println("ADDI $4 $4 1");
    			println("JUMP " + localLabelStr() + "while");
    			localLabel("end_while");
    			labelOrder++;

    			// $1 = $3
    			println("SET $1 $3");
    			destroy = true;
    			break;
    		case SUBI: opcode = "SUBI"; break;
    		case LTI: opcode = "LTI"; break;
			case GTI: opcode = "GTI"; break;
    		case EQI: opcode = "EQI"; break;
			case NEQI:
    			println("EQI $1 [$SP-1] [$SP]");
    			println("NOT $1 $1");
    			break;
    		case LTS: opcode = "LTS";  destroy = true; break;
			case GTS: opcode = "GTS"; destroy = true; break;
    		case EQS: opcode = "EQS"; destroy = true; break;
			case NEQS:
    			println("EQS $1 [$SP-1] [$SP]");
    			println("NOT $1 $1");
    			destroy = true; 
    			break;
    		case AND: opcode = "AND"; break;
			case OR: opcode = "OR"; break;
    	}

    	if(opcode != null) {
    		println(opcode + " $1 [$SP-1] [$SP]");
    	}
    	if(destroy) {
    		println("DESTROY [$SP-1]");
    		println("DESTROY [$SP]");
    	}
		println("SUBI $SP $SP 1");
    	println("SET [$SP] $1");
    }

    public static void code(Block block) {
    	block.statements.forEach(s -> code(s));
    }

    public static void code(Call call) {
    	Function f = call.function;
    	if(f.body == null) {
    		// Built-in function call
    		if(f.name.equals("print")) {
    			call.arguments.forEach(ex -> {
    				code(ex);
    				pop("$1");
    				if(ex.type == Type.INT) {
	    				print("WRITEI");
    				} else {
    					print("WRITES");
    				}
    				println(" $1");
    			});
    			return;
    		} else if(f.name.equals("readInt")) {
    			println("READI $1");
    			return;
    		} else if(f.name.equals("readString")) {
    			println("READS $1");
    			return;
    		}
    	}

    	if(call.contextObject == null) {
    		println("SET $1 " + "\"::" + f.name + "\"");
    	} else {
    		code(call.contextObject);
    		pop("$1");
    		println("GETWORD $1 $1 0");
    		println("GETWORD $1 $1 "+ f.order);
    	}

    	// store frame pointer
		push("$FP");

		// push arguments from right to left
		for(int i = call.arguments.size()-1; i >= 0; i--) {
			code(call.arguments.get(i));
		}

		// construct label and call, result will be in R1
		println("ADDI $SP $SP 1");
		println("CALL [$SP] $1");

		// pop return address and parameters
		println("SUBI $SP $SP " + (call.arguments.size()+1));

		// restore frame pointer
		pop("$FP");
    }

    public static String localLabelStr() {
    	return labelTemplate + ":" + labelOrder + ":";
    }

    public static void localLabel(String str) {
    	println("LABEL " + localLabelStr() + str);
    }

    public static void push(Variable src) {
    	push(String.format("[$FP%+d]", src.order));
    }

    public static void push(String src) {
		println("ADDI $SP $SP 1");
    	println("SET [$SP] " + src);
    }

    public static void pop(Variable dst) {
    	pop(String.format("[$FP%+d]", dst.order));
    }

    public static void pop(String dst) {
    	println("SET " + dst + " [$SP]");
		println("SUBI $SP $SP 1");
    }
    
    public static void returnVoid() {
    	println("SET $SP $FP");
        println("RETURN [$FP]");
    }
}